/**
 * Ïã§ÏãúÍ∞Ñ ÏïåÎ¶º Í¥ÄÎ¶¨ Hook
 * 
 * WebSocket Ïó∞Í≤∞ÏùÑ ÌÜµÌïú ÏïåÎ¶º ÏàòÏã†, ÏÉÅÌÉú Í¥ÄÎ¶¨, API Ìò∏Ï∂úÏùÑ Îã¥Îãπ
 */

import { useState, useEffect, useCallback, useRef } from 'react';
import { useAuth } from '@/hooks/useAuth';

export interface Notification {
  id: string;
  type: string;
  title: string;
  message: string;
  data?: any;
  userId?: string;
  role?: string;
  priority: 'low' | 'medium' | 'high' | 'urgent';
  timestamp: string;
  read: boolean;
  expiresAt?: string;
}

interface NotificationState {
  notifications: Notification[];
  unreadCount: number;
  loading: boolean;
  error: string | null;
  connected: boolean;
}

interface UseNotificationsReturn extends NotificationState {
  connect: () => void;
  disconnect: () => void;
  markAsRead: (notificationId: string) => void;
  markAllAsRead: () => void;
  deleteNotification: (notificationId: string) => void;
  sendTestNotification: () => void;
  updateSettings: (settings: any) => void;
  refreshNotifications: () => void;
}

export function useNotifications(): UseNotificationsReturn {
  const { user, isAuthenticated } = useAuth();
  const wsRef = useRef<WebSocket | null>(null);
  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const heartbeatIntervalRef = useRef<NodeJS.Interval | null>(null);
  
  const [state, setState] = useState<NotificationState>({
    notifications: [],
    unreadCount: 0,
    loading: false,
    error: null,
    connected: false,
  });

  // API Ìò∏Ï∂ú Ìó¨Ìçº
  const apiCall = useCallback(async (url: string, options: RequestInit = {}) => {
    try {
      const response = await fetch(url, {
        ...options,
        credentials: 'include',
        headers: {
          'Content-Type': 'application/json',
          ...options.headers,
        },
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      return await response.json();
    } catch (error) {
      console.error('API call failed:', error);
      throw error;
    }
  }, []);

  // ÏïåÎ¶º Î™©Î°ù Ï°∞Ìöå
  const fetchNotifications = useCallback(async () => {
    if (!isAuthenticated) return;

    try {
      setState(prev => ({ ...prev, loading: true, error: null }));
      
      const data = await apiCall('/api/notifications?limit=50');
      
      setState(prev => ({
        ...prev,
        notifications: data.data.notifications,
        unreadCount: data.data.unreadCount,
        loading: false,
      }));
    } catch (error) {
      setState(prev => ({
        ...prev,
        loading: false,
        error: error instanceof Error ? error.message : 'ÏïåÎ¶º Ï°∞Ìöå Ïã§Ìå®',
      }));
    }
  }, [isAuthenticated, apiCall]);

  // WebSocket Ïó∞Í≤∞
  const connect = useCallback(async () => {
    if (!isAuthenticated || !user || wsRef.current?.readyState === WebSocket.OPEN) {
      return;
    }

    try {
      // WebSocket ÌÜ†ÌÅ∞ ÏöîÏ≤≠
      const tokenData = await apiCall('/api/notifications/ws-token');
      const wsUrl = `${window.location.protocol === 'https:' ? 'wss:' : 'ws:'}//${window.location.host}${tokenData.data.wsUrl}`;
      
      setState(prev => ({ ...prev, error: null }));
      
      const ws = new WebSocket(wsUrl);
      wsRef.current = ws;

      ws.onopen = () => {
        console.log('üîî Notification WebSocket connected');
        setState(prev => ({ ...prev, connected: true, error: null }));
        
        // ÌïòÌä∏ÎπÑÌä∏ ÏÑ§Ï†ï
        heartbeatIntervalRef.current = setInterval(() => {
          if (ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: 'heartbeat' }));
          }
        }, 30000);
      };

      ws.onmessage = (event) => {
        try {
          const message = JSON.parse(event.data);
          handleWebSocketMessage(message);
        } catch (error) {
          console.error('WebSocket message parsing error:', error);
        }
      };

      ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        setState(prev => ({ 
          ...prev, 
          connected: false,
          error: 'ÏïåÎ¶º ÏÑúÎ≤Ñ Ïó∞Í≤∞ Ïò§Î•ò' 
        }));
      };

      ws.onclose = (event) => {
        console.log('üîî Notification WebSocket disconnected:', event.code, event.reason);
        setState(prev => ({ ...prev, connected: false }));
        
        // ÌïòÌä∏ÎπÑÌä∏ Ï†ïÎ¶¨
        if (heartbeatIntervalRef.current) {
          clearInterval(heartbeatIntervalRef.current);
          heartbeatIntervalRef.current = null;
        }
        
        // Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ (Ï†ïÏÉÅ Ï¢ÖÎ£åÍ∞Ä ÏïÑÎãå Í≤ΩÏö∞)
        if (event.code !== 1000 && isAuthenticated) {
          reconnectTimeoutRef.current = setTimeout(() => {
            console.log('üîÑ Attempting to reconnect...');
            connect();
          }, 5000);
        }
      };

    } catch (error) {
      console.error('WebSocket connection failed:', error);
      setState(prev => ({ 
        ...prev, 
        connected: false,
        error: error instanceof Error ? error.message : 'Ïó∞Í≤∞ Ïã§Ìå®' 
      }));
    }
  }, [isAuthenticated, user, apiCall]);

  // WebSocket Î©îÏãúÏßÄ Ï≤òÎ¶¨
  const handleWebSocketMessage = useCallback((message: any) => {
    switch (message.type) {
      case 'connection_established':
        console.log('üîî WebSocket connection established');
        setState(prev => ({ 
          ...prev, 
          unreadCount: message.data.unreadCount || 0 
        }));
        fetchNotifications();
        break;

      case 'notification':
        const notification = message.data;
        setState(prev => ({
          ...prev,
          notifications: [notification, ...prev.notifications],
          unreadCount: prev.unreadCount + 1,
        }));
        
        // Î∏åÎùºÏö∞Ï†Ä ÏïåÎ¶º ÌëúÏãú
        showBrowserNotification(notification);
        break;

      case 'notification_read':
        setState(prev => ({
          ...prev,
          notifications: prev.notifications.map(n => 
            n.id === message.data.notificationId 
              ? { ...n, read: true }
              : n
          ),
          unreadCount: Math.max(0, prev.unreadCount - 1),
        }));
        break;

      case 'all_notifications_read':
        setState(prev => ({
          ...prev,
          notifications: prev.notifications.map(n => ({ ...n, read: true })),
          unreadCount: 0,
        }));
        break;

      case 'server_shutdown':
        setState(prev => ({ 
          ...prev, 
          connected: false,
          error: 'ÏÑúÎ≤ÑÍ∞Ä Ï¢ÖÎ£åÎêòÏóàÏäµÎãàÎã§' 
        }));
        break;

      default:
        console.log('Unknown WebSocket message type:', message.type);
    }
  }, [fetchNotifications]);

  // Î∏åÎùºÏö∞Ï†Ä ÏïåÎ¶º ÌëúÏãú
  const showBrowserNotification = useCallback((notification: Notification) => {
    if ('Notification' in window && Notification.permission === 'granted') {
      new Notification(notification.title, {
        body: notification.message,
        icon: '/favicon.ico',
        tag: notification.id,
        requireInteraction: notification.priority === 'urgent',
      });
    }
  }, []);

  // WebSocket Ïó∞Í≤∞ Ìï¥Ï†ú
  const disconnect = useCallback(() => {
    if (wsRef.current) {
      wsRef.current.close(1000, 'Manual disconnect');
      wsRef.current = null;
    }
    
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current);
      reconnectTimeoutRef.current = null;
    }
    
    if (heartbeatIntervalRef.current) {
      clearInterval(heartbeatIntervalRef.current);
      heartbeatIntervalRef.current = null;
    }
    
    setState(prev => ({ ...prev, connected: false }));
  }, []);

  // ÏïåÎ¶ºÏùÑ ÏùΩÏùåÏúºÎ°ú ÌëúÏãú
  const markAsRead = useCallback(async (notificationId: string) => {
    try {
      await apiCall(`/api/notifications/${notificationId}/read`, { method: 'PUT' });
      
      // WebSocketÏúºÎ°ú Ï¶âÏãú ÏóÖÎç∞Ïù¥Ìä∏
      if (wsRef.current?.readyState === WebSocket.OPEN) {
        wsRef.current.send(JSON.stringify({
          type: 'mark_read',
          notificationId,
        }));
      }
    } catch (error) {
      console.error('Mark as read failed:', error);
    }
  }, [apiCall]);

  // Î™®Îì† ÏïåÎ¶ºÏùÑ ÏùΩÏùåÏúºÎ°ú ÌëúÏãú
  const markAllAsRead = useCallback(async () => {
    try {
      await apiCall('/api/notifications/read-all', { method: 'PUT' });
      
      // WebSocketÏúºÎ°ú Ï¶âÏãú ÏóÖÎç∞Ïù¥Ìä∏
      if (wsRef.current?.readyState === WebSocket.OPEN) {
        wsRef.current.send(JSON.stringify({ type: 'mark_all_read' }));
      }
    } catch (error) {
      console.error('Mark all as read failed:', error);
    }
  }, [apiCall]);

  // ÏïåÎ¶º ÏÇ≠Ï†ú
  const deleteNotification = useCallback(async (notificationId: string) => {
    try {
      await apiCall(`/api/notifications/${notificationId}`, { method: 'DELETE' });
      
      setState(prev => ({
        ...prev,
        notifications: prev.notifications.filter(n => n.id !== notificationId),
        unreadCount: prev.notifications.find(n => n.id === notificationId && !n.read) 
          ? prev.unreadCount - 1 
          : prev.unreadCount,
      }));
    } catch (error) {
      console.error('Delete notification failed:', error);
    }
  }, [apiCall]);

  // ÌÖåÏä§Ìä∏ ÏïåÎ¶º Ï†ÑÏÜ°
  const sendTestNotification = useCallback(async () => {
    if (process.env.NODE_ENV !== 'development') return;
    
    try {
      await apiCall('/api/notifications/test', { method: 'POST' });
    } catch (error) {
      console.error('Test notification failed:', error);
    }
  }, [apiCall]);

  // ÏïåÎ¶º ÏÑ§Ï†ï ÏóÖÎç∞Ïù¥Ìä∏
  const updateSettings = useCallback(async (settings: any) => {
    try {
      await apiCall('/api/notifications/settings', {
        method: 'PUT',
        body: JSON.stringify(settings),
      });
      
      // WebSocket Íµ¨ÎèÖ ÏóÖÎç∞Ïù¥Ìä∏
      if (wsRef.current?.readyState === WebSocket.OPEN) {
        wsRef.current.send(JSON.stringify({
          type: 'subscribe',
          subscriptions: settings.subscriptions,
        }));
      }
    } catch (error) {
      console.error('Update settings failed:', error);
    }
  }, [apiCall]);

  // ÏïåÎ¶º Î™©Î°ù ÏÉàÎ°úÍ≥†Ïπ®
  const refreshNotifications = useCallback(() => {
    fetchNotifications();
  }, [fetchNotifications]);

  // Î∏åÎùºÏö∞Ï†Ä ÏïåÎ¶º Í∂åÌïú ÏöîÏ≤≠
  useEffect(() => {
    if ('Notification' in window && Notification.permission === 'default') {
      Notification.requestPermission();
    }
  }, []);

  // Ïù∏Ï¶ù ÏÉÅÌÉú Î≥ÄÍ≤Ω Ïãú Ïó∞Í≤∞ Í¥ÄÎ¶¨
  useEffect(() => {
    if (isAuthenticated && user) {
      connect();
      fetchNotifications();
    } else {
      disconnect();
    }
    
    return () => disconnect();
  }, [isAuthenticated, user, connect, disconnect, fetchNotifications]);

  // Ïª¥Ìè¨ÎÑåÌä∏ Ïñ∏ÎßàÏö¥Ìä∏ Ïãú Ï†ïÎ¶¨
  useEffect(() => {
    return () => {
      disconnect();
    };
  }, [disconnect]);

  return {
    ...state,
    connect,
    disconnect,
    markAsRead,
    markAllAsRead,
    deleteNotification,
    sendTestNotification,
    updateSettings,
    refreshNotifications,
  };
}

export default useNotifications;