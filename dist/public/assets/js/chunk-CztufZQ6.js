import{ar as H,as as N}from"./chunk-CuLW_54J.js";import{r as a,cP as L}from"./chunk-Dd62wDmJ.js";const U="popstate",y="pushState",P="replaceState",V="hashchange",R=[U,y,P,V],B=e=>{for(const t of R)addEventListener(t,e);return()=>{for(const t of R)removeEventListener(t,e)}},w=(e,t)=>H.useSyncExternalStore(B,e,t),I=()=>location.search,M=({ssrSearch:e=""}={})=>w(I,()=>e),x=()=>location.pathname,T=({ssrPath:e}={})=>w(x,e?()=>e:x),$=(e,{replace:t=!1,state:n=null}={})=>history[t?P:y](n,"",e),q=(e={})=>[T(e),$],C=Symbol.for("wouter_v3");if(typeof history<"u"&&typeof window[C]>"u"){for(const e of[y,P]){const t=history[e];history[e]=function(){const n=t.apply(this,arguments),s=new Event(e);return s.arguments=arguments,dispatchEvent(s),n}}Object.defineProperty(window,C,{value:!0})}const z=(e,t)=>t.toLowerCase().indexOf(e.toLowerCase())?"~"+t:t.slice(e.length)||"/",_=(e="")=>e==="/"?"":e,G=(e,t)=>e[0]==="~"?e.slice(1):_(t)+e,J=(e="",t)=>z(k(_(e)),k(t)),k=e=>{try{return decodeURI(e)}catch{return e}},j={hook:q,searchHook:M,parser:N,base:"",ssrPath:void 0,ssrSearch:void 0,hrefs:e=>e},K=a.createContext(j),p=()=>a.useContext(K),O={},A=a.createContext(O),Q=()=>a.useContext(A),d=e=>{const[t,n]=e.hook(e);return[J(e.base,t),L((s,c)=>n(G(s,e.base),c))]},W=()=>d(p()),E=(e,t,n,s)=>{const{pattern:c,keys:i}=t instanceof RegExp?{keys:!1,pattern:t}:e(t||"*",s),u=c.exec(n)||[],[f,...l]=u;return f!==void 0?[!0,(()=>{const r=i!==!1?Object.fromEntries(i.map((m,g)=>[m,l[g]])):u.groups;let o={...l};return r&&Object.assign(o,r),o})(),...s?[f]:[]]:[!1,null]},te=e=>E(p().parser,e,W()[0]),X=({children:e,...t})=>{const n=p(),s=t.hook?j:n;let c=s;const[i,u]=t.ssrPath?.split("?")??[];u&&(t.ssrSearch=u,t.ssrPath=i),t.hrefs=t.hrefs??t.hook?.hrefs;let f=a.useRef({}),l=f.current,r=l;for(let o in s){const m=o==="base"?s[o]+(t[o]||""):t[o]||s[o];l===r&&m!==r[o]&&(f.current=r={...r}),r[o]=m,m!==s[o]&&(c=r)}return a.createElement(K.Provider,{value:c,children:e})},S=({children:e,component:t},n)=>t?a.createElement(t,{params:n}):typeof e=="function"?e(n):e,Y=e=>{let t=a.useRef(O),n=t.current;for(const s in e)e[s]!==n[s]&&(n=e);return Object.keys(e).length===0&&(n=e),t.current=n},ne=({path:e,nest:t,match:n,...s})=>{const c=p(),[i]=d(c),[u,f,l]=n??E(c.parser,e,i,t),r=Y({...Q(),...f});if(!u)return null;const o=l?a.createElement(X,{base:l},S(s,r)):S(s,r);return a.createElement(A.Provider,{value:r,children:o})},se=a.forwardRef((e,t)=>{const n=p(),[s,c]=d(n),{to:i="",href:u=i,onClick:f,asChild:l,children:r,className:o,replace:m,state:g,...F}=e,v=L(h=>{h.ctrlKey||h.metaKey||h.altKey||h.shiftKey||h.button!==0||(f?.(h),h.defaultPrevented||(h.preventDefault(),c(u,e)))}),b=n.hrefs(u[0]==="~"?u.slice(1):n.base+u,n);return l&&a.isValidElement(r)?a.cloneElement(r,{onClick:v,href:b}):a.createElement("a",{...F,onClick:v,href:b,className:o?.call?o(s===u):o,children:r,ref:t})}),D=e=>Array.isArray(e)?e.flatMap(t=>D(t&&t.type===a.Fragment?t.props.children:t)):[e],re=({children:e,location:t})=>{const n=p(),[s]=d(n);for(const c of D(e)){let i=0;if(a.isValidElement(c)&&(i=E(n.parser,c.props.path,t||s,c.props.nest))[0])return a.cloneElement(c,{match:i})}return null};export{se as L,ne as R,re as S,Q as a,te as b,W as u};
